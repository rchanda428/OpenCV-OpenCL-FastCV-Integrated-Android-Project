// Include Files#include <stdlib.h>#include <android/log.h>#include <time.h>#include <fastcv/fastcv.h>#include "opencv2/opencv.hpp"#include "opencv2/imgcodecs.hpp"#include "opencv2/imgproc.hpp"#include <opencv2/core.hpp>#include "opencv2/core/ocl.hpp"#include "loadjpeg.h"//==============================================================================// Declarations//==============================================================================#define LOG_TAG    "loadjpeg.cpp"#define DPRINTF(...)  __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG,__VA_ARGS__)#define IPRINTF(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)#define EPRINTF(...)  __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)using namespace cv;using namespace ocl;//==============================================================================// Function Declarations//==============================================================================//==============================================================================// Function Definitions//==============================================================================void setOpenCL(){    ocl::setUseOpenCL(true);    if (!ocl::haveOpenCL()) {        DPRINTF("OpenCL is not available...\n");        //return;    }    cv::ocl::Context context;    if (!context.create(cv::ocl::Device::TYPE_GPU)) {        DPRINTF("Failed creating the context...\n");        //return;    }    //This bit provides an overview of the OpenCL devices you have in your computer    DPRINTF("GPU devices are detected[%ld].\n",context.ndevices());    for (int i = 0; i < context.ndevices(); i++) {        cv::ocl::Device device = context.device(i);        //std::cout << "name:              " << device.name() << std::endl;        DPRINTF("name:[%s]\n",device.name().c_str());        //std::cout << "available:         " << device.available() << std::endl;        DPRINTF("available:[%d]\n",device.available());        //std::cout << "imageSupport:      " << device.imageSupport() << std::endl;        DPRINTF("imageSupport:[%d]\n",device.imageSupport());        //std::cout << "OpenCL_C_Version:  " << device.OpenCL_C_Version() << std::endl;        DPRINTF("name:[%s]\n",device.OpenCL_C_Version().c_str());    }    ocl::Device(context.device(0));}void dummyUMatCopy(){    int width=3840;    int height=2160;    cv::Mat testInMat(cv::Size(width,height),CV_8UC1);//declare matrix with widthxheight as size    testInMat=0;//initialise testInMat with zeros    UMat testInUmat;    clock_t start2=clock();    //testInMat.copyTo(testInUmat);//copyfromcputogpu    testInUmat = testInMat.getUMat(ACCESS_READ);    clock_t stop2=clock();    double elapsed2 =(double)(stop2-start2)*1000.0/CLOCKS_PER_SEC;    DPRINTF("Time Taken by testInMat copyTo:%f milisecond",elapsed2);}void dummyUMatImageCopy(){    UMat imgInUMat, gray;    Mat imgInMat = imread("/storage/emulated/0/SamplePNGImage_5mbmb.png", IMREAD_COLOR); //read image into cpu mat    /*file_example_JPG_1MB.jpg has 3800x2534 resolution*/    clock_t start=clock();    //imgInMat.copyTo(imgInUMat);  //copy mat from cpu to gpu    imgInUMat = imgInMat.getUMat(ACCESS_FAST);    clock_t stop=clock();    double elapsed=(double)(stop-start)*1000.0/CLOCKS_PER_SEC;    DPRINTF("Time Taken by dummy imgInMat copyTo:[%f]milisecond\n",elapsed);    cvtColor(imgInUMat, gray, COLOR_BGR2GRAY);    imwrite("/storage/emulated/0/dummyoutputInGray.jpg", gray);}void testWarpAffine(){    double mIRMatrix[6] = { 1, 0, 0, 0, 1, 0 };    cv::Mat Matrix = cv::Mat(2, 3, CV_64FC1,&mIRMatrix);    cv::UMat UMatrix;    Matrix.copyTo(UMatrix);    cv::UMat WarpedIRMat;    UMat opencvwarpaffineUMAT1;    Mat opencvwarpaffinedstUMAT1;    cv::imread("/storage/emulated/0/opencvTesting/wp4473260.jpg").copyTo(opencvwarpaffineUMAT1);    cv::warpAffine(opencvwarpaffineUMAT1, WarpedIRMat, Matrix, Size(opencvwarpaffineUMAT1.cols, opencvwarpaffineUMAT1.rows));    cv::warpAffine(opencvwarpaffineUMAT1, WarpedIRMat, Matrix, Size(opencvwarpaffineUMAT1.cols, opencvwarpaffineUMAT1.rows));    cv::warpAffine(opencvwarpaffineUMAT1, WarpedIRMat, Matrix, Size(opencvwarpaffineUMAT1.cols, opencvwarpaffineUMAT1.rows));    cv::ocl::finish();    std::chrono::high_resolution_clock::time_point testWarpAffineStart = std::chrono::high_resolution_clock::now();    cv::warpAffine(opencvwarpaffineUMAT1, WarpedIRMat, Matrix, Size(opencvwarpaffineUMAT1.cols, opencvwarpaffineUMAT1.rows));    cv::ocl::finish();    std::chrono::high_resolution_clock::time_point testWarpAffineEnd = std::chrono::high_resolution_clock::now();    DPRINTF("test warpaffine Operation Time:[%lf]msec",std::chrono::duration<double, std::milli>(testWarpAffineEnd-testWarpAffineStart).count());    WarpedIRMat.copyTo(opencvwarpaffinedstUMAT1);    cv::imwrite("/storage/emulated/0/opencvTesting/opencvwarpaffinestUMATToMat.jpg", opencvwarpaffinedstUMAT1);}void testAddWeight(){    float32_t srcAlpha = 0.5;    float32_t srcBeta = 0.5;    Mat opencvblenddstUMATToMat;//using umat    UMat opencvblendinputUMAT1,opencvblendinputUMAT2,opencvblenddstUMAT;    cv::imread("/storage/emulated/0/opencvTesting/wp4473260.jpg").copyTo(opencvblendinputUMAT1);    cv::imread("/storage/emulated/0/opencvTesting/wp4473263.jpg").copyTo(opencvblendinputUMAT2);    cv::ocl::finish();    std::chrono::high_resolution_clock::time_point testAddWeightStart = std::chrono::high_resolution_clock::now();//    addWeighted(opencvblendinputUMAT1,srcAlpha,opencvblendinputUMAT2,srcBeta,0,opencvblenddstUMAT);    Mat srcAlphaInMat(opencvblendinputUMAT1.rows,opencvblendinputUMAT1.cols,CV_32FC1,Scalar(0.5,0.5,0.5));    blendLinear(opencvblendinputUMAT1,opencvblendinputUMAT2,srcAlphaInMat,srcAlphaInMat,opencvblenddstUMAT);    cv::ocl::finish();    std::chrono::high_resolution_clock::time_point testAddWeightEnd = std::chrono::high_resolution_clock::now();    DPRINTF("test addweighted Operation Time:[%lf]msec",std::chrono::duration<double, std::milli>(testAddWeightEnd-testAddWeightStart).count());    opencvblenddstUMAT.copyTo(opencvblenddstUMATToMat);    cv::imwrite("/storage/emulated/0/opencvTesting/opencvblenddstUMATToMat.jpg", opencvblenddstUMATToMat);}void testMultiply(){    Mat opencvmultiplydstUMATToMat;//using umat    UMat opencvmultiplyinputUMAT1,opencvmultiplyinputUMAT2,opencvmultiplydstUMAT;    cv::imread("/storage/emulated/0/opencvTesting/wp4473260.jpg").copyTo(opencvmultiplyinputUMAT1);    cv::imread("/storage/emulated/0/opencvTesting/wp4473263.jpg").copyTo(opencvmultiplyinputUMAT2);//    multiply(opencvmultiplyinputUMAT1,opencvmultiplyinputUMAT2,opencvmultiplydstUMAT);    cv::ocl::finish();    std::chrono::high_resolution_clock::time_point testMultiplyStart = std::chrono::high_resolution_clock::now();    multiply(opencvmultiplyinputUMAT1,opencvmultiplyinputUMAT2,opencvmultiplydstUMAT);    cv::ocl::finish();    std::chrono::high_resolution_clock::time_point testMultiplyEnd = std::chrono::high_resolution_clock::now();    DPRINTF("test multiply Operation Time:[%lf]msec",std::chrono::duration<double, std::milli>(testMultiplyEnd-testMultiplyStart).count());    opencvmultiplydstUMAT.copyTo(opencvmultiplydstUMATToMat);    cv::imwrite("/storage/emulated/0/opencvTesting/opencvmultiplydstUMATToMat.jpg", opencvmultiplydstUMATToMat);}void testBoxFilter(){    UMat opencvfilterinputUMAT,opencvfilterdstUMAT;    Mat opencvfilterdstUMATToMat;    Point point1 = Point(-1, -1);    cv::imread("/storage/emulated/0/opencvTesting/wp4473260.jpg").copyTo(opencvfilterinputUMAT);    cv::ocl::finish();    std::chrono::high_resolution_clock::time_point BoxFilterstart = std::chrono::high_resolution_clock::now();    boxFilter(opencvfilterinputUMAT, opencvfilterdstUMAT, -1, cv::Size(16,16), point1, true, BORDER_DEFAULT);//blur(opencvfilterinputUMAT,opencvfilterdstUMAT,Size(3,3));    cv::ocl::finish();    std::chrono::high_resolution_clock::time_point BoxFilterend = std::chrono::high_resolution_clock::now();    DPRINTF("test boxFilter Operation Time:[%lf]msec",std::chrono::duration<double, std::milli>(BoxFilterend-BoxFilterstart).count());    opencvfilterdstUMAT.copyTo(opencvfilterdstUMATToMat);    cv::imwrite("/storage/emulated/0/opencvTesting/opencvcvboxfilterUMATToMat.jpg", opencvfilterdstUMATToMat);}extern "C" JNIEXPORT void JNICALLJava_com_qualcomm_loadjpeg_LoadJpeg_testPerformance(JNIEnv *env, jobject thiz) {    // TODO: implement testPerformance()    DPRINTF("Java_com_qualcomm_loadjpeg_LoadJpeg_testPerformance JNI entry");    testAddWeight();//        testBoxFilter();//    testWarpAffine();//    testMultiply();#if 0    setOpenCL();    //dummyUMatCopy();    //dummyUMatImageCopy();    UMat imgInUMat, gray;    Mat imgInMat = imread("/storage/emulated/0/file_example_JPG_1MB.jpg", IMREAD_COLOR); //read image into cpu mat    /*file_example_JPG_1MB.jpg has 3800x2534 resolution*/    clock_t start=clock();    //imgInMat.copyTo(imgInUMat);  //copy mat from cpu to gpu    //imgInUMat = imgInMat.getUMat(ACCESS_FAST);    //imgInUMat = imgInMat.getUMat(ACCESS_FAST,cv::USAGE_ALLOCATE_DEVICE_MEMORY);    imgInUMat = imgInMat.getUMat(ACCESS_FAST,cv::USAGE_ALLOCATE_HOST_MEMORY);//giving best time taken 0.026msec    //imgInUMat = imgInMat.getUMat(ACCESS_RW,cv::USAGE_ALLOCATE_HOST_MEMORY); //giving worst time taken i.e 30msec    //imgInUMat = imgInMat.getUMat(ACCESS_READ,cv::USAGE_ALLOCATE_HOST_MEMORY); //giving avg worst i.e 7msec    //imgInUMat = imgInMat.getUMat(ACCESS_FAST,cv::USAGE_ALLOCATE_SHARED_MEMORY); //giving avg worst i.e 7msec    clock_t stop=clock();    double elapsed=(double)(stop-start)*1000.0/CLOCKS_PER_SEC;    DPRINTF("Time Taken by imgInMat copyTo:[%f]milisecond\n",elapsed);    cvtColor(imgInUMat, gray, COLOR_BGR2GRAY);    imwrite("/storage/emulated/0/outputInGray.jpg", gray);#endif#if 0    int width=3840;    int height=2160;    cv::Mat testInMat(cv::Size(width,height),CV_8UC1);//declare matrix with widthxheight as size    testInMat=0;//initialise testInMat with zeros    UMat testInUmat;    clock_t start2=clock();    testInMat.copyTo(testInUmat);//copyfromcputogpu    clock_t stop2=clock();    double elapsed2 =(double)(stop2-start2)*1000.0/CLOCKS_PER_SEC;    DPRINTF("Time Taken by testInMat copyTo:%f milisecond",elapsed2);#endif    DPRINTF("Java_com_qualcomm_loadjpeg_LoadJpeg_testPerformance JNI exit");}